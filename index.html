  // Your Telegram and Monetag Details
  const BOT_TOKEN = '8254257053:AAG3D7CaqN1FtQ7Ltl2NVF_q85ZarmiZwFs'; 
  const CHAT_ID = '5965219037';
  const MONETAG_ZONE_ID = '9572158';

  let currentUsername = localStorage.getItem('currentUsername') || null;
  let verificationCode = null;
  let tempUserData = {};

  function sendTelegramNotification(chatId, message) {
    const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage?chat_id=${chatId}&text=${encodeURIComponent(message)}&parse_mode=HTML`;
    fetch(url)
      .then(response => response.json())
      .then(data => {
        if (!data.ok) {
          console.error("Failed to send Telegram message:", data.description);
        }
      })
      .catch(error => {
        console.error("Error sending Telegram message:", error);
      });
  }

  function sendTelegramImageNotification(chatId, imageFile, caption) {
    const formData = new FormData();
    formData.append('chat_id', chatId);
    formData.append('photo', imageFile);
    formData.append('caption', caption);

    const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`;

    fetch(url, {
      method: 'POST',
      body: formData
    })
    .then(response => response.json())
    .then(data => {
      if (!data.ok) {
        console.error("Failed to send image:", data.description);
      }
    })
    .catch(error => {
      console.error("Error sending image:", error);
    });
  }

  function showModal() {
    document.getElementById('verificationModal').style.display = 'block';
  }
  function closeModal() {
    document.getElementById('verificationModal').style.display = 'none';
  }

  function checkLoginStatus() {
    if (currentUsername) {
      document.getElementById('authSections').classList.add('hidden');
      document.getElementById('mainApp').classList.remove('hidden');
      document.getElementById('appNav').style.display = 'flex';
      loadUserData(currentUsername);
    } else {
      document.getElementById('authSections').classList.remove('hidden');
      document.getElementById('mainApp').classList.add('hidden');
      document.getElementById('appNav').style.display = 'none';
    }
  }

  function showLogin() {
    document.getElementById('loginSection').classList.remove('hidden');
    document.getElementById('registerSection').classList.add('hidden');
  }

  function showRegister() {
    document.getElementById('loginSection').classList.add('hidden');
    document.getElementById('registerSection').classList.remove('hidden');
  }

  function handleRegistration(e) {
    e.preventDefault();
    const username = document.getElementById('reg_username').value;
    const password = document.getElementById('reg_password').value;
    const telegramChatId = document.getElementById('reg_chat_id').value;
    
    if (!username.startsWith('@')) {
        alert("‚ùå Username must start with '@'.");
        return;
    }
    if (password.length < 8) {
        alert("‚ùå Password must be at least 8 characters long.");
        return;
    }
    if (telegramChatId.length !== 10) {
        alert("‚ùå Telegram Chat ID must be exactly 10 digits long.");
        return;
    }
    
    if (localStorage.getItem(username)) {
      alert("‚ùå This username is already taken!");
      return;
    }
    
    verificationCode = Math.floor(1000 + Math.random() * 9000).toString();
    sendTelegramNotification(telegramChatId, `Your verification code is: <b>${verificationCode}</b>`);
    
    tempUserData = {
      username: username,
      password: password,
      chatId: telegramChatId,
      balance: 0,
      withdraw: 0,
      tasks: 0,
      ads: 0
    };
    
    showModal();
  }
  
  function verifyCode(e) {
    e.preventDefault();
    const submittedCode = document.getElementById('verificationCodeInput').value;
    
    if (submittedCode === verificationCode) {
      localStorage.setItem(tempUserData.username, JSON.stringify(tempUserData));
      alert("‚úÖ Registration successful! Please log in.");
      closeModal();
      showLogin();
      verificationCode = null;
      tempUserData = {};
      document.getElementById('verificationCodeInput').value = '';
    } else {
      alert("‚ùå Incorrect verification code.");
    }
  }

  function handleLogin(e) {
    e.preventDefault();
    const username = document.getElementById('login_username').value;
    const password = document.getElementById('login_password').value;
    
    const userData = JSON.parse(localStorage.getItem(username));
    if (userData && userData.password === password) {
      currentUsername = username;
      localStorage.setItem('currentUsername', username);
      checkLoginStatus();
    } else {
      alert("‚ùå Invalid username or password.");
    }
  }

  let balance, withdraw, tasks, ads;
  let currentUserChatId;

  function loadUserData(username) {
    const userData = JSON.parse(localStorage.getItem(username));
    balance = userData.balance;
    withdraw = userData.withdraw;
    tasks = userData.tasks;
    ads = userData.ads;
    currentUserChatId = userData.chatId;

    document.getElementById('profileUsername').innerHTML = `<b>${username}</b>`;
    updateUI();
  }

  function updateUI() {
    document.getElementById("balance").innerText = balance;
    document.getElementById("withdraw").innerText = withdraw;
    document.getElementById("tasks").innerText = tasks;
    document.getElementById("ads").innerText = ads;
    document.getElementById("profileWithdraw").innerText = withdraw;
    document.getElementById("profileTasks").innerText = tasks;
    document.getElementById("profileAds").innerText = ads;
  }

  function saveData() {
    const userData = {
      username: currentUsername,
      password: JSON.parse(localStorage.getItem(currentUsername)).password,
      chatId: currentUserChatId,
      balance: balance,
      withdraw: withdraw,
      tasks: tasks,
      ads: ads
    };
    localStorage.setItem(currentUsername, JSON.stringify(userData));
  }
  
  function showSection(id, element) {
    document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
    document.getElementById(id).classList.add("active");
    
    document.querySelectorAll("nav button").forEach(btn => btn.classList.remove("active-nav"));
    element.classList.add("active-nav");
    
    updateUI();

    if (id !== 'gameSection') {
      endGame();
    }
  }

  function showRewardedAd() {
    // This is a placeholder for your Monetag Rewarded Ad code.
    // Please replace this with the actual code provided by Monetag.
    // The following code simulates a successful ad view.

    alert("Simulating ad view... Please wait.");
    setTimeout(() => {
        balance += 10;
        ads += 1;
        saveData();
        alert("‚úÖ You earned 10 points!");
        updateUI();
    }, 1500);
  }

  function showTasks() {
    var html = `
      <div class="task-item">
        <span><b>Task 1:</b> Subscribe to our Telegram Channel.</span>
        <a href="https://t.me/your_channel_link" target="_blank" class="btn btn-secondary">
          <i class="fab fa-telegram"></i>Go to Task
        </a>
        <form onsubmit="submitTask(event, 5, 'Telegram Channel')">
          <input type="file" accept="image/*" required>
          <button type="submit" class="btn btn-primary">Submit Screenshot</button>
        </form>
      </div>
      <div class="task-item">
        <span><b>Task 2:</b> Join our Discord Group.</span>
        <a href="https://discord.gg/your_discord_link" target="_blank" class="btn btn-secondary">
          <i class="fab fa-discord"></i>Go to Task
        </a>
        <form onsubmit="submitTask(event, 5, 'Discord Group')">
          <input type="file" accept="image/*" required>
          <button type="submit" class="btn btn-primary">Submit Screenshot</button>
        </form>
      </div>
      <div class="task-item">
        <span><b>Task 3:</b> Follow us on Twitter.</span>
        <a href="https://twitter.com/your_twitter_profile" target="_blank" class="btn btn-secondary">
          <i class="fab fa-twitter"></i>Go to Task
        </a>
        <form onsubmit="submitTask(event, 5, 'Twitter Follow')">
          <input type="file" accept="image/*" required>
          <button type="submit" class="btn btn-primary">Submit Screenshot</button>
        </form>
      </div>
      <div class="task-item">
        <span><b>Task 4:</b> Like our Facebook Page.</span>
        <a href="https://facebook.com/your_page" target="_blank" class="btn btn-secondary">
          <i class="fab fa-facebook"></i>Go to Task
        </a>
        <form onsubmit="submitTask(event, 5, 'Facebook Page')">
          <input type="file" accept="image/*" required>
          <button type="submit" class="btn btn-primary">Submit Screenshot</button>
        </form>
      </div>
      <div class="task-item">
        <span><b>Task 5:</b> Visit our Website.</span>
        <a href="https://example.com" target="_blank" class="btn btn-secondary">
          <i class="fas fa-globe"></i>Go to Task
        </a>
        <form onsubmit="submitTask(event, 5, 'Website Visit')">
          <input type="file" accept="image/*" required>
          <button type="submit" class="btn btn-primary">Submit Screenshot</button>
        </form>
      </div>
    `;
    document.getElementById("taskList").innerHTML = html;
  }

  function submitTask(e, points, taskName) {
    e.preventDefault();
    const fileInput = e.target.querySelector('input[type="file"]');
    const file = fileInput.files[0];
    
    tasks += 1;
    balance += points;
    saveData();
    
    alert("üì∑ Screenshot submitted. You earned " + points + " points!");
    updateUI();

    const caption = `<b>New Task Submission!</b>\n<b>User:</b> ${currentUsername}\n<b>Task Name:</b> ${taskName}`;
    sendTelegramImageNotification(CHAT_ID, file, caption);
  }

  function submitWithdraw(e) {
    e.preventDefault();
    const amount = parseInt(document.getElementById("amount").value);
    const number = document.getElementById("number").value;
    
    if (amount > balance) {
      alert("‚ùå Not enough balance.");
      return;
    }
    
    withdraw += amount;
    balance -= amount;
    saveData();
    
    alert("‚úÖ Withdraw submitted! Remaining balance: " + balance + ".");
    updateUI();
    document.getElementById("number").value = '';
    document.getElementById("amount").value = '';

    const withdrawMessage = `<b>New Withdraw Request!</b>\n<b>User:</b> ${currentUsername}\n<b>Number:</b> ${number}\n<b>Amount:</b> ${amount}\n<b>Chat ID:</b> ${currentUserChatId}`;
    sendTelegramNotification(CHAT_ID, withdrawMessage);
  }

  // ===== Bubble Shooter Game Logic Start (‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá) =====
  let gameInterval;
  let canvas, ctx;
  let bubbles = [];
  let shooterBubble;
  let currentScore = 0;
  let gameActive = false;
  let shotsSinceDrop = 0;

  const bubbleRadius = 15;
  const bubbleColors = ['#FF4136', '#FF851B', '#FFDC00', '#2ECC40', '#0074D9'];
  const gridRows = 5;
  const gridCols = 12;
  const bubbleSpacing = 3;
  const dropDistance = bubbleRadius * 2 + bubbleSpacing;
  
  // ‡¶ó‡ßç‡¶∞‡¶ø‡¶° ‡¶™‡¶ú‡¶ø‡¶∂‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶æ‡¶¨‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
  function createBubble(col, row) {
    const x = (col * bubbleRadius * 2) + (row % 2 === 0 ? bubbleRadius + bubbleSpacing : bubbleRadius * 2 + bubbleSpacing);
    const y = row * dropDistance + bubbleRadius + bubbleSpacing;
    const color = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
    return { x, y, color, radius: bubbleRadius };
  }

  function createBubbleGrid() {
    bubbles = [];
    for (let row = 0; row < gridRows; row++) {
      const currentGridCols = gridCols - (row % 2);
      for (let col = 0; col < currentGridCols; col++) {
        bubbles.push(createBubble(col, row));
      }
    }
  }

  function createShooterBubble() {
    shooterBubble = {
      x: canvas.width / 2,
      y: canvas.height - 30,
      radius: bubbleRadius,
      color: bubbleColors[Math.floor(Math.random() * bubbleColors.length)],
      isShot: false,
      speedX: 0,
      speedY: 0
    };
  }

  function startBubbleShooter() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    canvas.addEventListener('click', shootBubble);

    document.getElementById('bubbleShooterGame').style.display = 'block';
    
    gameActive = true;
    currentScore = 0;
    shotsSinceDrop = 0;
    createBubbleGrid();
    createShooterBubble();

    gameInterval = setInterval(updateGame, 1000 / 60);
  }

  function endGame() {
    if (!gameActive) return;
    clearInterval(gameInterval);
    gameActive = false;
    alert(`Game Over! Your final score is: ${currentScore}`);
    
    balance += Math.floor(currentScore / 100);
    saveData();
    updateUI();
    
    document.getElementById('bubbleShooterGame').style.display = 'none';
  }
  
  function updateGame() {
    if (!gameActive) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawBubbles();
    drawShooter();
    
    if (shooterBubble.isShot) {
      shooterBubble.x += shooterBubble.speedX;
      shooterBubble.y += shooterBubble.speedY;

      // ‡¶¨‡¶æ‡¶â‡¶®‡ßç‡¶∏ ‡¶≤‡¶ú‡¶ø‡¶ï
      if (shooterBubble.x - shooterBubble.radius < 0 || shooterBubble.x + shooterBubble.radius > canvas.width) {
        shooterBubble.speedX *= -1;
      }

      // ‡¶â‡¶™‡¶∞‡ßá‡¶∞ ‡¶¶‡ßá‡¶ì‡ßü‡¶æ‡¶≤‡ßá ‡¶¨‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶¨‡¶æ‡¶¨‡¶≤‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ß‡¶æ‡¶ï‡ßç‡¶ï‡¶æ ‡¶ñ‡¶æ‡¶ì‡ßü‡¶æ‡¶∞ ‡¶≤‡¶ú‡¶ø‡¶ï
      let collision = false;
      if (shooterBubble.y - shooterBubble.radius <= 0) {
        collision = true;
        // ‡¶â‡¶™‡¶∞‡ßá ‡¶ß‡¶æ‡¶ï‡ßç‡¶ï‡¶æ ‡¶ñ‡ßá‡¶≤‡ßá ‡¶ó‡ßç‡¶∞‡¶ø‡¶°‡ßá ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶π‡¶¨‡ßá
        const snapX = shooterBubble.x;
        const snapY = bubbleRadius + bubbleSpacing;
        addAndCheckBubble(snapX, snapY, shooterBubble.color);
      } else {
        for (let i = 0; i < bubbles.length; i++) {
          const dx = shooterBubble.x - bubbles[i].x;
          const dy = shooterBubble.y - bubbles[i].y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < bubbleRadius * 2) {
            collision = true;
            // ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶¨‡¶æ‡¶¨‡¶≤‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ß‡¶æ‡¶ï‡ßç‡¶ï‡¶æ ‡¶ñ‡ßá‡¶≤‡ßá ‡¶ó‡ßç‡¶∞‡¶ø‡¶°‡ßá ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶π‡¶¨‡ßá
            addAndCheckBubble(shooterBubble.x, shooterBubble.y, shooterBubble.color);
            break;
          }
        }
      }

      if (collision) {
        shooterBubble.isShot = false;
        shotsSinceDrop++;
        if (shotsSinceDrop % 3 === 0) {
            dropBubbles();
        }
        createShooterBubble();
      }
    }
    
    checkForGameOver();
  }

  // ‡¶®‡¶§‡ßÅ‡¶® ‡¶¨‡¶æ‡¶¨‡¶≤ ‡¶ó‡ßç‡¶∞‡¶ø‡¶°‡ßá ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶´‡¶æ‡¶ü‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ
  function addAndCheckBubble(x, y, color) {
    // ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶ï‡¶æ‡¶õ‡ßá‡¶∞ ‡¶ó‡ßç‡¶∞‡¶ø‡¶° ‡¶™‡¶ú‡¶ø‡¶∂‡¶® ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
    const row = Math.round((y - bubbleRadius - bubbleSpacing) / dropDistance);
    const currentGridCols = gridCols - (row % 2);
    const col = Math.round((x - (row % 2 === 0 ? bubbleRadius + bubbleSpacing : bubbleRadius * 2 + bubbleSpacing)) / (bubbleRadius * 2));
    
    const snapX = (col * bubbleRadius * 2) + (row % 2 === 0 ? bubbleRadius + bubbleSpacing : bubbleRadius * 2 + bubbleSpacing);
    const snapY = row * dropDistance + bubbleRadius + bubbleSpacing;

    const newBubble = { x: snapX, y: snapY, color, radius: bubbleRadius };
    bubbles.push(newBubble);

    // ‡¶è‡¶ï‡¶á ‡¶∞‡¶ô‡ßá‡¶∞ ‡¶¨‡¶æ‡¶¨‡¶≤ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶´‡¶æ‡¶ü‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ
    const matchingBubbles = findMatchingBubbles(newBubble);
    if (matchingBubbles.length >= 3) {
      removeBubbles(matchingBubbles);
      currentScore += matchingBubbles.length * 10;
      removeFloatingBubbles();
    }
  }

  // ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶¨‡¶≤‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶è‡¶ï‡¶á ‡¶∞‡¶ô‡ßá‡¶∞ ‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶¨‡¶æ‡¶¨‡¶≤ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
  function findMatchingBubbles(startBubble) {
    const stack = [startBubble];
    const visited = new Set();
    const connected = [];
    const minDistance = bubbleRadius * 2 - 1; // ‡¶¶‡ßÇ‡¶∞‡¶§‡ßç‡¶¨ ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á‡ßü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡¶π‡¶®‡¶∂‡ßÄ‡¶≤‡¶§‡¶æ

    while (stack.length > 0) {
        const currentBubble = stack.pop();
        const key = `${currentBubble.x},${currentBubble.y}`;

        if (visited.has(key)) continue;
        visited.add(key);
        connected.push(currentBubble);

        for (const otherBubble of bubbles) {
            if (otherBubble.color === currentBubble.color && !visited.has(`${otherBubble.x},${otherBubble.y}`)) {
                const dx = currentBubble.x - otherBubble.x;
                const dy = currentBubble.y - otherBubble.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < minDistance) {
                    stack.push(otherBubble);
                }
            }
        }
    }
    return connected;
  }
  
  // ‡¶¨‡¶æ‡¶¨‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
  function removeBubbles(bubblesToRemove) {
    bubbles = bubbles.filter(bubble => !bubblesToRemove.includes(bubble));
  }

  // ‡¶≠‡¶æ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶¨‡¶æ‡¶¨‡¶≤ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
  function removeFloatingBubbles() {
    const connectedToTop = new Set();
    const stack = [];

    // ‡¶â‡¶™‡¶∞‡ßá‡¶∞ ‡¶∏‡¶æ‡¶∞‡¶ø‡¶∞ ‡¶¨‡¶æ‡¶¨‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï‡ßá ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ
    for (const bubble of bubbles) {
      if (bubble.y <= dropDistance + bubbleRadius + 1) { // ‡¶ü‡¶™ ‡¶∞‡ßã ‡¶è‡¶∞ ‡¶Ü‡¶∂‡ßá‡¶™‡¶æ‡¶∂‡ßá
        stack.push(bubble);
        connectedToTop.add(bubble);
      }
    }

    // DFS/BFS ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶¨‡¶æ‡¶¨‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
    while (stack.length > 0) {
      const currentBubble = stack.pop();
      for (const otherBubble of bubbles) {
        if (!connectedToTop.has(otherBubble)) {
          const dx = currentBubble.x - otherBubble.x;
          const dy = currentBubble.y - otherBubble.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < bubbleRadius * 2 - 1) {
            stack.push(otherBubble);
            connectedToTop.add(otherBubble);
          }
        }
      }
    }

    // ‡¶Ø‡ßá ‡¶¨‡¶æ‡¶¨‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶®‡ßü, ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶æ
    const floatingBubbles = bubbles.filter(bubble => !connectedToTop.has(bubble));
    if (floatingBubbles.length > 0) {
      bubbles = bubbles.filter(bubble => connectedToTop.has(bubble));
      currentScore += floatingBubbles.length * 10;
    }
  }

  function drawBubbles() {
    for (const bubble of bubbles) {
      ctx.beginPath();
      ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
      ctx.fillStyle = bubble.color;
      ctx.fill();
      ctx.closePath();
    }
  }

  function drawShooter() {
    ctx.beginPath();
    ctx.arc(shooterBubble.x, shooterBubble.y, shooterBubble.radius, 0, Math.PI * 2);
    ctx.fillStyle = shooterBubble.color;
    ctx.fill();
    ctx.closePath();
  }

  function shootBubble(e) {
    if (!gameActive || shooterBubble.isShot) return;

    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    const angle = Math.atan2(clickY - shooterBubble.y, clickX - shooterBubble.x);
    const speed = 10;
    
    shooterBubble.speedX = Math.cos(angle) * speed;
    shooterBubble.speedY = Math.sin(angle) * speed;
    shooterBubble.isShot = true;
  }

  function dropBubbles() {
    for (const bubble of bubbles) {
      bubble.y += dropDistance;
    }
  }
  
  function checkForGameOver() {
    for (const bubble of bubbles) {
      if (bubble.y + bubble.radius >= canvas.height - 30) {
        endGame();
        break;
      }
    }
  }
  
  window.onload = () => {
    checkLoginStatus();
    const homeButton = document.querySelector('nav button:first-child');
    if (homeButton) {
      showSection('home', homeButton);
    }
  };
</script>
